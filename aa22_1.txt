2022년 Associate Architect 양성과정
선발 평가(1차)
OOP/OOAD/UML

1. 다음은 객체지향 (Object-Oriented) 기본 개념 중 무엇을 설명하는 것인가요?
“Design, produce and describe software so that it can be easily used without knowing the
details of how it works.”
➀ Abstraction
➁ Encapsulation
➂ Polymorphism
➃ Inheritance

2. OOAD (Object-Oriented Analysis and Design)에 대한 다음의 설명 중 가장 올바르지 않은
것은?
➀ Object-Oriented Program을 개발하기 위한 소프트웨어 개발 방법론(Methodology) 중 하나이다.
➁ OOA (Object-Oriented Analysis)는 해당 도메인에서 사용되는 Concepts/Objects를 찾는 단계이다.
➂ OOD (Object-Oriented Design)는 개발할 Software Object을 정확하게 정의하는단계이다.
➃ OOD에서는 사용할 데이터의 흐름(Data Flow)을 명확하게 정의하는 것이 중요하다.

3. 다음은 UML 2.2를 구성하는 14종의 다이어그램을 Class Diagram을 이용해서 정리한 그림입
니다. 이들 중 3개만 OOAD에서 사용할 수 있다고 한다면, 어떤 다이어그램을 선택하는 것이 가
장 효과적일까요?
➀ Use Case – Package - Deployment
➁ Sequence – Communication - Component
➂ Use Case – Class - Sequence
➃ Class – Package - Component

4. UML에 대한 다음의 설명 중 가장 올바르지 않은 것은?
➀ UML은 OOAD 뿐만 아니라 다양한 목적으로 사용되는 범용의 모델링 언어이다.
➁ UML은 개발자를 위한 도구이므로, UML로 작성한 모델이 요구사항명세서(SRS)와
같은 공식적인 문서에 부분적으로 포함될 수도 있다.
➂ UML은 개발자를 위한 도구이므로, 개발자 간 의사소통의 도구로 사용하면 편리하다.
➃ UML을 잘 사용할 수 있는 능력과 Object-Oriented 방식으로 생각(디자인)을 
잘 하는 능력은 밀접한 상관 관계가 있다.

5. 다음은 UP의 4 Phases 중 어느 단계에 대한 설명인가요?
“Architecture가 나중에 변경되어야 하는 Risk를 해결하기 위해, Architecture에 민감한 요구사항
들을 모두 찾고, 이를 모두 반영한 가장 적절한 Architecture를 선정한다.”
➀ Inception
➁ Elaboration
➂ Construction
➃ Transition


6. UP 기반 OOAD 방법론은 Risk-driven한 방법론입니다. 이에 대한 다음의 설명 중 가장 올바
르지 않은 것은?
➀ UP는 개발 초기에 SW Architecture가 계속 바뀌는 Risk를 줄이고자 한다.
➁ UP는 다양한 SW Architecture를 시도해 봄으로써 Architectural Risk를 줄이고자 한다.
➂ UP는 Client가 최종 개발 산출물과 일부 기능에 대해 인수 거부를 선언하는 Risk를줄이고자 한다.
➃ UP는 Risk를 줄이기 위해서 이해관계자가 모두 참여하는 Requirements Workshop을 개최한다.


7. 다음은 UP에서 사용되는 여러 Diagram (모델) 중 무엇에 대한 설명인가요?
“External Actor와 System 간의 모든 Interactions을 찾아서, a set of System Operations을 도출
하는 목적으로 사용된다.”
➀ Domain Model
➁ System Sequence Diagram
➂ Data Flow Diagram
➃ Use-Case Diagram


8. Visibility에 대한 다음의 설명 중 올바르지 않은 것은?
➀ Visibility는 한 Object가 다른 Object에 (Public으로) 정의된 모든 Attributes와
Operations을 볼 수 있는 능력(Ability)을 의미한다.
➁ Sequence Diagram 상에서, Object A가 Object B로 메시지를 보낸다면, A는 B를 볼
수 (Visible) 있어야 한다는 개념이다.
➂ Local Visibility는 가장 기본적이고 많이 사용되는 Visibility로서, Class Diagram과
Sequence Diagram을 통해 쉽게 확인할 수 있다.
➃ UML 모델링 도구를 사용할 때, Sequence Diagram으로 두 Object 간의
Communication을 선언하면, Class Diagram에서도 해당 Object/Class 간의 
선(Association)이 자동으로 그어지는 것과 같은 원리이다.


9. OOAD (Object-Oriented Analysis and Design)에 대한 다음의 설명 중 가장 올바른 것은?
➀ Domain Model은 일종의 Class Diagram으로서, 가능하면 자세히 작성해야, OOD
단계에서 Class Diagram을 작성할 때 도움이 많이 된다.
➁ OOA 단계에서는 요구사항을 정리한 Use Case가 가장 중요하다.
➂ OOD 단계에서는 Skeleton 코드를 생성하는 대상인 Class Diagram이 가장 중요하다.
➃ OOAD에서는, 현 Iteration에서 구현할 기능에 대해, Sequence Diagrams과 Class
Diagram을 반복적(Iterative)이고 점증적(Incremental)으로 작성한다.


10. 다음의 Class Diagram에 대한 설명 중 올바르지 않은 것은?
 
➀ 같은 Person에서 파생(Inherit/Generalized) 되었으므로, Employee와 Student의
Public Operations은 모두 동일하다.
➁ 모든 Employee는 Person이다.
➂ 모든 Professor는 Person이다.
➃ Professor는 Person이 가질 수 있는 모든 Class Relationship을 가질 수 있다.


11. 다음의 Statechart Diagram에서, start, e12, e9, e12, e5 의 순서로 이벤트가 차례대로 발생되
는 경우, 최종적으로 도달된 상태는 무엇인가요?
(최대길이 : 4000)
 S5.1


12. 다음의 Sequence Diagram에서 해석 가능한 모든 Order of Messages (Message Sequence)는
총 몇 개 인가요?
  6


13. 다음의 Class Diagram의 Register 클래스에는 모두 몇 개의 “Private” attribute이 정의되나
요?
 5?


14. UP Environment Discipline에서 작성되는 Artifact로서, 계획하는 프로젝트에서 앞으로 생성
할 UP Artifacts와 사용할 Practices의 선택 결과를 정리한 Artifact는 무엇인가요?
Development Case


15. 다음은 교재의 POS 예제의 “Process Sale” Use-Case와 관련된 Package Diagram의 일부입
니다. 기본적인 3 Layered Architecture를 가정합니다. 외부에 있는 Cashier로부터 시작된
“endSale( )”과 UI Layer의 ProcessSale Frame 클래스에서 시작된 “endSale( )”의 차이점을 설명
하세요. 단, 현재 시점을 UP의 Construction Phase 후반부라고 가정합니다.
 
외부 Actor인 Casher와 직접적으로 communication하는 endSale()은 systemoperation으로서 UI등으로 처리되는 부분이고 
Domain과 UI를 연결하는 endSale()은 register class에 있는 public operation이다.


16. 다음은 UP의 Environment Discipline에서 작성하는 Development Case를 설명하는 그림입
니다. SW Architecture Document가 Construction Phase에서 빈칸으로 되어 있는데, 그 빈칸의
의미와 이유를 정확하게 설명하세요.
 
Elaboration phase에서 Architecture는 fix되며 그 이후 단계인 construction phase부터는 수정이 되지 않는 다는 뜻이다.
UP 기반 OOAD는 architecture-centricm하기 때문에 architecture critical한 부분을 
elaboration단계에서 fix하고 나머지 단계에서는 architecture 와 관련이 없고 user에게 critical한 use case를 해결한다.


17. 다음은 학생(Student)이 학교시스템(StudentAdminSystem)에 시험을 등록(Register) 하는 시
나리오에 대한 시스템 수준의 Sequence Diagram입니다. 시험 등록이 불가능할 경우, Waiting
List에 등록(Register)하도록 설계되어 있습니다. 이 Sequence Diagram을 보고 코드를 구현하는
구현자(Implementor/Programmer)를 혼란스럽게 할 가능성이 있는 부분을 하나 찾고 그 이유를
간단히 설명하세요.

 

OPT에서 [retister on WL == true]인 경우만 있어서 [register on WL == false]경우
Student는 아무런 register에 대한 message를 받지 못함


18. 다음의 Sequence Diagram을 보고, System Operation systemOP( )의 body를 C++ 또는
JAVA로 최대한 정확하게 작성하세요. 단, systemOP( )와 직접적으로 연관되고 필요한 부분까지
정확하게 작성합니다.
 

현재 첨부되어 있는 파일 : 17035482_정병욱_OOP&OOAD&UML_설계형18.txt

19. 다음은 (문항17)에서 소개된 학교시스템(SystemAdminSystem) 전체에 대한 Class Diagram
으로서, 디자인 초기 단계에 작성되었습니다. (문항17)에서 제시된 Sequence Diagram의 내용이
모두 반영되도록 아래의 Class Diagram을 수정/확장 디자인하세요. 단, StudyProgram 클래스는
“학과/전공”을 의미하며, (문항17)의 Database도 포함해야 합니다. (수정/확장된 부분만 제출하
세요.)
  

20. (문항19)에서 수정/확장한 Class Diagram을 기준으로, 다음의 Use Case를 만족하는 (디자인
수준의) Sequence Diagram을 작성하세요.
 
 
 
 
 
 
 
 
Design Patterns
1. 좋은 설계를 이끌어내는 올바른 지침을 모두 고른 것은?
(a) 리스코프의 치환 원칙을 지키면서 설계한다.
(b) 클래스의 모듈성(modularity)을 향상시키기 위해 정보 은닉(information hiding)을 활용한다.
(c) 클래스 간 연결에 의존(dependency) 보다는 합성(composition)을 더 선호하면서 설계한다.
(d) 구체 클래스(concrete class)를 만들 때 추상 클래스(abstract class)에서 상속받기 보다는 또
다른 구체 클래스로부터 상속받고 불필요한 메쏘드는 예외(exception) 처리 등을 통해 퇴화
(deprecate)시킨다.
➀ (a), (b)
➁ (c), (d)
➂ (a), (b), (c)
➃ (b), (c), (d)


2. 다음 상황과 가장 밀접한 설계 악취(design smell)를 고르시오.
“시스템의 어느 한 부분을 수정했는데 전혀 관련되지 않다고 생각한 다른 부분이 잘못 동작한다.”
➀ 부동성(immobility)
➁ 강건성(robustness)
➂ 취약성(fragility)
➃ 혼잡성(crowdedness)


3. 설계 원칙 SRP에 대한 설명으로 가장 적절한 것은?
➀ 변화하기 쉬운 것 보다는 변화하기 어려운 것에 의존해야 한다는 원칙이다.
➁ 클래스 간 상속관계가 올바른지 체크해 볼 수 있는 원칙이다.
➂ 클라이언트는 자신이 사용하지 않는 인터페이스에 대해 의존하지 말아야 한다는 원칙이다.
➃ 반복자 (iterator) 패턴에서 강조되어 반복자와 집합 객체(aggregate object)의 분리를 이끌어 냈다.


4. 다음 중 객체 합성(object composition)과 위임(delegation)을 통해 동작하는 패턴을 모두 고른것은?
(a) 장식자(decorator) 패턴
(b) 반복자(iterator) 패턴
(c) 팩토리 메쏘드(factory method) 패턴
➀ (a), (b)
➁ (a), (c)
➂ (b), (c)
➃ (a), (b), (c)


5. 다음 중 GoF 패턴의 분류에서 나머지 패턴들과 다른 목적의 패턴으로 분류되는 것을 고르시오.
➀ 가교(bridge) 패턴
➁ 적응자(adapter) 패턴
➂ 복합체(composite) 패턴
➃ 전략(strategy) 패턴


6. 다음 중 올바르지 않은 것은?
➀ 메쏘드 오버로딩(overloading)은 다형성(polymorphism)의 예이다.
➁ 메쏘드 오버라이딩을 사용하면 호출될 메쏘드가 런타임(run-time)에 결정된다.
➂ 템플릿 메쏘드(template method) 패턴은 객체 합성(object composition)을 이용한다.
➃ 추상 팩토리(abstract factory) 패턴은 메쏘드 오버라이딩을 이용한다.


7. MVC 패턴에 대해 올바른 것을 모두 고르면?
(a) 뷰(View)에 복합체(composite) 패턴이 적용되어 있다.
(b) 뷰와 모델(model) 사이에 감시자 (observer) 패턴이 적용되어 있다.
(c) 뷰보다는 모델이 더 자주 변경될 것이라는 가정을 가지고 있다.
➀ (a), (b)
➁ (a), (c)
➂ (b), (c)
➃ (a), (b), (c)


8. UML 클래스 다이어그램에서 옳은 문장을 모두 고른 것은?
(a) 인터페이스(interface)는 상수 이외의 멤버 변수(member variable)를 가질 수 없다.
(b) 추상 클래스(abstract class)는 추상 메쏘드(abstract method)를 하나 이상 포함해야 한다.
(c) 추상 메쏘드의 인자(parameter)로 구체 클래스(concrete class) 타입을 사용할 수 있다.
➀ (a), (b)
➁ (a), (c)
➂ (b), (c)
➃ (a), (b), (c)


9. 설계 원칙 ISP에 대한 설명으로 가장 옳은 것은?
➀ 해당 원칙을 위반하면 컴파일 에러가 발생된다.
➁ 해당 원칙을 지켜야 OCP가 만족될 수 있다.
➂ 해당 원칙을 지키는 설계를 통해 인터페이스의 응집도(cohesion)를 높일 수 있다.
➃ 이용 편이성을 위해 여러 클라이언트(client)의 인터페이스 요구를 한번에 담을 수
있는 폭넓은 (fat) 인터페이스의 채용이 필요하다는 의미이다.


10. 다음 중 상태(State) 패턴과 상대적으로 가장 관련이 적은 것은?
➀ 위임(delegation)을 통해 유연성을 증대시킨다.
➁ 변화하는 것을 캡슐화(encapsulation)시켜서 내부 설계 결정이 바뀌더라도 외부에 미치는 영향을 최소화한다.
➂ 구현보다는 인터페이스에 대해 프로그래밍하여 이를 통해 구현에 변화가 생기더라도 
   외부에 미치는 영향을 최소화한다.
➃ 문제 영역(problem domain)의 개념을 나타내지 않는 클래스를 도입하여 
  낮은 결합도와 높은 응집력을 가지도록 설계한다.


11. 다음 클래스 다이어그램에서 Int1을 변경했을 때, 직접적 혹은 간접적으로 그 영향을 받을 수
있는 모든 클래스와 인터페이스를 나열하시오. (단, 그림에 나타나지 않은 hidden coupling은 없
다고 가정한다)
 C3,
A2, C2, A3


12. 다음 클래스 다이어그램을 자바 혹은 C++로 구현했을 때, 에러 없이 동작되는 코드를 모두
고르시오.
 

 (a) A1 a = new C1( ); // in Java
A1 *a = new C1; // in C++
(b) A2 b = new C1( ); // in Java
A2 *b = new C1; // in C++
(c) Int1 c = new A2( ); // in Java
Int1 *c = new A2; // in C++
(d) Int1 d = new C2( ); // in Java
Int1 *d = new C2; // in C++
(e) C3 e = new C4( ); // in Java
C3 *e = new C4; // in C++
(f) Int2 f = new C4( ); // in Java
Int2 *f = new C4; // in C++
(g) A2 g = new C4( ); // in Java
A2 *g = new C4; // in C++
(h) Int1 h = new C4( ); // in Java
Int1 *h = new C4; // in C++

a, d, e, f, g ,h


13. 다음 설명에 가장 적합한 GoF 패턴 이름을 쓰시오.
“도메인 논리 계층(Domain Logic Layer)을 사용자 인터페이스 계층(User Interface Layer)과 분
리하여 시스템을 구축하고자 한다. 특히 도메인 논리 계층에 있는 도메인 객체(domain object)의
상태가 변화되면, 사용자 인터페이스 계층에 위치한 하나 이상의 객체에 대해 알려주고자 한다.
이러한 통신(communication)을 허용하면서도, 도메인 논리 계층의 도메인 객체들로부터 사용자
인터페이스 계층의 객체에 대한 커플링을 약화시키고 싶으며, 사용자 인터페이스 계층에 위치한
객체들의 갯수가 증가하거나 감소할 수 있다."

observer pattern

14. 다음 설명에 가장 적합한 GoF 패턴 이름을 쓰시오.
"이 패턴은 어떤 집합에 속해 있는 객체들의 상호 작용을 조정(control)하는 객체(이하 해당 객체
를 X라 칭함)를 1개로 한정시킨다. 이 객체 X는 상호 작용 관계에 있는 동료(colleague) 객체들
이 직접 서로를 참조하지 않도록 함으로써 동료 객체들간의 느슨한 연결을 촉진시키며, 객체들의
상호작용을 독립적으로 다양화할 수 있도록 해준다. 이를 위해 X는 상호 작용에 대한 로직(logic)
을 캡슐화(encapsulation)하여 자신의 코드로서 구현하게 된다. "

mediator patern


15. 다음 코드에 적용된 패턴 이름을 GoF 패턴 23가지 중에 하나를 골라서 쓰고 그 이유를 설명
하시오.
public class Client {
  public static void main (String args [ ] ) {
    ServiceProvider sp = new Service1Provider ( );     
    sp.startService( );
  }
}

abstract class ServiceProvider {   
  Server s = null;
  
  protected abstract Server createServer();   
  
  public void startService( ) {
    s = createServer( );      
    writeLog ( s );
  }
  
  protected void writeLog ( Server s ) {
    // generate log message about s  
 }
}

class Service1Provider extends ServiceProvider { 
  protected Server createServer( ) { return new ServerA( ); } 
}
class Service2Provider extends ServiceProvider { 
  protected Server createServer( ) { return new ServerB( ); } 
}

interface Server { }
class ServerA implements Server {   // implementing Server interface here }
class ServerB implements Server {   // implementing Server interface here }

Strategy Pattern.
ServiceProvider에 따라 다른 Server에 대한 implementation(algorithm)을
이를 object composition & delegation으로 구현하였다.
즉, 다른 Server에대한 구현이 createServer()라는 동일한 interface에 program되어 있다.




16. 다음 코드를 보고 물음에 대해 답하시오.
class P {
  public T m(S x) { ... } }
class C extends P {
public T1 m(S1 x) { ... } 
}

위의 클래스 정의가 에러 없이 컴파일되고 C의 m 메쏘드가 P의 m 메쏘드를 오버라이드
(override)하기 원할 때,
(a) T1 타입과 T 타입의 가능한 모든 관계를 말하시오. 
(예를 들어 "T1이 T의 하위 타입 혹은 같은 타입이어야 한다" 등으로 표현할 것)
(b) S 타입과 S1 타입의 가능한 모든 관계를 말하시오.


(a) T1타입과 T타입은 독립적이다.
(b) (1) S와 S1은 같은 타입.




17. 다음 클래스 다이어그램으로 표현된 설계를 보고 답하시오. 단, Client1~4의 메쏘드 관련 코
드는 아래 표현된 것이 전부이며 그 내용이 향후 변경될 가능성은 거의 없다고 가정하시오.
 


(a) 위 설계에서 GRASP 원칙 혹은 SOLID 원칙 중 위반된 것을 1개 고르고, 위반된 원칙의 이름
과 함께 그렇게 생각하는 이유를 쓰시오.
(b) 위반된 원칙을 지킬 수 있도록 설계를 어떻게 개선할 수 있을지 구체적으로 설명하시오.

(a) ISP위반. ISP는 Client가 자기가 쓰지 않는 method에 의존하지 않아야 하는데, 위
예제는 IFoo에 모든 method들을 필요하지 않은 경우에도 가리킬 수 있다.
(b) service1(), service2(), service3()을 관련 그룹끼리 묶어 interface 다시 정의하여
사용한다.




18. 아래 그림에서 타겟 인터페이스(Target Interface)는 ServiceInterface로 표현되어 있으며,
ServiceImpl 클래스는 어댑티(Adaptee) 클래스에 해당한다.
타겟 인터페이스와 어댑티 클래스의 매핑 관계는 다음과 같다:
- selectAService()를 호출하면 ServiceImpl의 Service1()을 호출함
- selectBService()를 호출하면 ServiceImpl의 Service2()을 호출함
(a) 객체 적응자(Object Adapter) 구현과 (b) 클래스 적응자(Class Adapter) 패턴의 구현을 자바
혹은 C++ 언어로 제시하시오 또한, 클라이언트 프로그램이 각 구현을 사용하는 코드도 제시하시
오.
 
 
 

19. 다음 코드에 나타난 클래스 S를 싱글턴 패턴으로 만들기 위한 구현을 최소한의 수정을 통해 제시하시오. 단, 멀티쓰레드(multi-thread) 사용을 고려할 필요는 없으며 자바 혹은 C++ 언어로 표현하시오. 
// in Java class S {
  private int a1;
  public X a2;
  public void set_a1(int a) { this.a1 = a; }
  public S(int b1, X b2) {     this.a1 = b1;
    this.a2 = b2;   }
}
class X { private int a3; } // in C++
class S {
  private: int a1;   public: 
    X* a2;
    void set_a1(int a) { this.a1 = a; }     S(int b1, X* b2) {
      this.a1 = b1;       this.a2 = b2;     }
}
class X { private: int a3; }  




20. 변수(소문자 캐릭터 1개로 표현되며 저장된 값은 float 타입)와 사칙 연산자(operator) - 덧
셈(Plus), 뺄셈(Minus), 곱셈(Mult), 나눗셈(Div) - 로 구성된 임의의 수식(Expression)을 장식자
(decorator) 패턴을 이용해서 표현하고자 한다. 연산의 결과는 항상 실수(float 타입)라고 가정하
며, 모든 사칙 연산자의 피연산자(operand)의 갯수는 두 개로 고정한다. 즉, 단항 (unary) 연산자
는 지원할 필요 없다.
(a) 위 내용을 장식자(decorator) 패턴을 사용해서 설계한 코드(자바 혹은 C++)를 쓰시오. (그림
으로 부가적으로 표현할 수는 있으나 반드시 코드로 작성)
(b) 해당 설계를 기반으로 다음 예제의 수식들을 만들어내는 코드를 보이시오.
가. a
나. (a - b) * c
다. ( ( c * d ) / ( a - b ) ) * b
