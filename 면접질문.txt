Software Architect?
A Software development expert who makes high-level design choices and dictates technical standards, including software coding standards, tools and platforms.
High level 설계를 선택하고 소프트웨어 코딩 표준, 도구 및 플랫폼을 포함한 기술 표준을 지시하는 소프트웨어 개발 전문가입니다.

Software Architecture?
Software architecture refers to the high-level structures of a software system and the discipline of creating such structures
소프트웨어 아키텍처는 소프트웨어 시스템의 상위 수준 구조와 그러한 구조를 만드는 분야를 나타냅니다.
-	Schematic Architecture
 A structured and visual representation of the structural elements of a target system, their roles, and relationships among the elements. A stable foundation for making further architectural decisions.
 대상 시스템의 구조적 요소, 해당 역할, 요소 간 관계를 체계적이고 시각적으로 표현한 것입니다. 추가 아키텍처 결정을 위한 안정적인 기반
-	Design for Architecture View
1) Functional view, - 함수 data처리 
2) Information view, - data관점의 설계
3) Behavior view, - 실행순서 관련, 기능이 아니다. 
4) Deployment view, -
-	Design for NFR

SD) Class Diagram있는데 구조를 나타내는 Compound Diagram있나?
-	Class Diagram + Sequence Diagram: 클래스 구조와 객체 간의 상호작용을 동시에 보여줌으로써 정적 구조와 동적 행동을 결합하여 이해를 돕습니다.
-	Component Diagram + Deployment Diagram: 소프트웨어 구성 요소와 물리적 배포 구성을 함께 보여줌으로써 소프트웨어의 논리적 구조와 물리적 배포를 연계시켜 설명합니다.
-	Package Diagram + Class Diagram: 패키지 간의 관계를 고수준에서 보여주면서 각 패키지 내부의 클래스 구조를 세부적으로 나타냅니다.
SEI 4+1 View
-	Logical / Structural View, - Functionality
-	Process / Behavior View,  - performance
-	Development(Developer) / Implementation View, - software management
-	Physical / Deployment View. – system topology
-	+1 Scenario / Use Case View

ISO 9126, Conventional NFRs
-	Functionality: Suitability, Accuracy, Interoperability, Security
-	Reliability: Maturity, Recoverability, Availability
-	Usability: Understandability, Learnability, Operability
-	Efficiency: Performance, Resource Utilization
-	Maintainability: Analyzability, Changeability, Stability, Testability
-	Portability: Adaptability, Convertibility, Compatibility

DFD Diagram
-	Process (O)
-	Terminal (ㅁ)
-	Data Store (=)
-	Data Flow ()

DFD for boundary Context
-	System Functionality ↔ Process of DFD
-	Elements in Boundary ↔ Terminal of DFD
-	Persistent Data ↔ Data Store of DFD
-	Informational Flow ↔ Data Flow of DFD

UCD include, extend?
-	Include: 한 use case가 다른 use case를 포함하는 관계를 나타냅니다. 이는 한 use case가 수행되는 과정에서 다른 use case가 필수적으로 포함되어야 하는 경우에 사용됩니다.
-	Extend: 한 use case가 다른 use case를 확장하는 관계를 나타냅니다. 이는 한 use case가 수행되는 과정에서 다른 use case의 기능을 추가로 사용하는 경우에 사용됩니다.

Design 단계에서의 High Level Class Diagram 
-	Persistent data
-	Functional Component 

Key Elements of CD
-	Class
-	Relationaships
	Dependency   ---------▷ 
	Association    ────>
	Aggregation ◇────>
	Composition ◆────>
	Inheritance    ────▷

HAL의 주된 사용 용도는? 어떨 때 쓰면 좋은가?
-	HW Specific을 user에게 숨기고 interface를 제공 (SD)
-	HW와 SW분리하여 HW 호완성 보장하고 SW 개발 및 유지보수 용이성 제공

Mediator pattern vs Facace pattern차이?
Mediator 패턴은 객체 간의 상호작용을 중앙 집중화하여 관리하고, Facade 패턴은 복잡한 서브시스템의 인터페이스를 단순화하여 사용자가 쉽게 접근할 수 있도록 합니다.

Required Interface 용도
-	SW 시스템 유지 보수 / 확장 쉽게 한다
-	가변적 기능은 required interface 밖에서 구현 ex) template method pattern

Why is required interface essential in designing platform SW?
-	Required interface는 시스템의 모듈 간 통신과 상호작용을 명확히 정의하며, 소프트웨어의 유연성, 확장성, 유지보수성을 크게 향상시킨다.
-	독립성, 재사용성 유지보수성 향상, 유연성과 확장성 제공한다.

Class method (static), Class attribute (static) 용도?
-	Instance간의 통계 counting, class수준 관리

Software Defined X (SDx) :  x --> everything
다양한 기술 영역에서 소프트웨어 정의 접근 방식을 채택한 것을 의미합니다. SDx는 하드웨어 중심의 전통적인 시스템에서 벗어나 소프트웨어 중심의 유연하고 효율적인 시스템을 만드는 데 중점을 둡니다

Digital twin?
디지털 트윈(Digital Twin)은 물리적 객체, 시스템, 프로세스 또는 공간의 디지털 복제본을 의미합니다. 이는 실제 세계의 자산이나 환경을 가상 세계에 재현하여 실시간 데이터를 통해 상태를 모니터링하고, 시뮬레이션 및 분석을 수행하며, 예측 및 최적화를 가능하게 합니다. 디지털 트윈은 IoT(사물 인터넷), 빅 데이터, AI(인공지능) 등 다양한 기술을 활용하여 구현됩니다.

Action과 Activity의 차이가 무엇인가?
-	action과 activity는 둘 다 행동을 나타내지만, 그 추상화 수준과 역할에 차이가 있습니다
-	Action : 가장 작은 행동 단위입니다. 일반적으로 한 단계의 작업을 나타내며, 더 이상 쪼갤 수 없는 원자적 행동을 의미합니다
-	Activity: 여러 action을 포함하는 더 큰 단위의 행동을 나타냅니다. 여러 action들이 모여 특정 목표를 달성하기 위한 흐름을 나타냅니다

Try-catch vs switch-case 차이?
-	공통점: Fault나면 실행
-	차이점: SoC ( Separation of Concern )  try: main logic 만 생각하고 
catch: 별도로 생각하자는 idea
-	생각의 관점이 다른 try-catch로 분리하여 각 모듈이 특정 기능적 관심사만을 처리하도록 분리함으로써, 시스템의 복잡성을 줄이고, 코드의 재사용성, 유지보수성, 확장성을 향상시키는 데 도움을 줍니다

State Machine Diagram은 어떤 정보를 주는가?
-	Target component안에 state가 몇개 인지 보인다
-	State 허용 가능한 state transition보인다. 
-	State Machine Diagram은 시스템의 동작을 상태와 전이로 시각화하여, 시스템이 특정 이벤트나 조건에 따라 어떻게 반응하는지 명확히 보여줍니다. 이를 통해 객체의 라이프사이클, 복잡한 제어 흐름, 시스템 동작 분석, 디버깅, 테스트, 문서화 등에 큰 도움을 줍니다.

Consistency between Functional & Behavior
-	Mapping activity/action for a given use case
-	Mapping use cases for a given action/activity

Observer pattern은 어떤 situation에서 사용하는가?
-	Observer 패턴은 객체의 상태 변화가 있을 때, 그 변화를 감지하고 이에 대응하여 다른 객체들에 알림을 주어야 할 때 유용하게 사용됩니다. 이는 주로 객체들 간의 1대다(one-to-many) 의존성을 정의하는 상황에서 사용됩니다.
-	상태 변경 알림: 객체의 상태가 변경될 때, 그 변화를 여러 객체들에게 통지해야 하는 경우에 사용됩니다.
-	실시간 데이터 피드: 실시간으로 업데이트되는 데이터를 여러 객체들이 구독(subscribe)하고, 데이터가 업데이트될 때마다 이를 수신해야 하는 경우에 사용됩니다. 예를 들어, 주식 시장 데이터 피드, 스포츠 경기 결과 업데이트 등이 있습니다
-	모델-뷰 관계: 모델(Model)과 뷰(View) 간의 관계에서 모델의 상태가 변경될 때 뷰가 이를 반영해야 하는 경우에 사용됩니다. 이는 주로 MVC (Model-View-Controller) 아키텍처에서 모델과 뷰 간의 동기화를 위해 사용됩니다

---------------------------------------------------------------------------

What is the typical drawback of procedural programs such as C?
-	함수단위로 코드 재사용이 가능하지만, OOP 언어에비해 재사용성이 떨어짐. 
-	새로운 기능을 추가하거나 수정할 때 기존코드 재사용하는데 한계 있음.
-	유지보수 어려워: 프로그램 복잡해질수록 유지보수 어렵, 코드가 길어질수록 의존성 높아짐. 
-	데이터 보안 및 은닉의 부족 : 함수가 데이터를 접근 및 수정이 자유로움, 데이터 
-	은닉 어려워
-	다형성 & 상속의 부재: 코드의 유연성 과 확정성 제한

What is the difference between Abstract Class and Interface?
-	Abstract Class는 일부 method를 구현하고 다른 메서드는 abstract method를  선언하여 하위 class에서 반드시 구현하도록 요구할 수 있습니다. 
-	Interface는 모든 method를 abstract method로만 선언하며, 구현은 하위 클래스에서 이루어져야 합니다.


Why is dynamic binding essential in OOP? 
OOP에서 동적 바인딩은 왜 필수적인가?
-	유연성 증가: 프로그램 실행 시점에 메서드 호출이 결정되기 때문에, 코드가 더 적응력 있고 확장 가능한 구조를 가질 수 있다. 
-	Polymorphism: 같은 인터페이스나 부모 클래스를 공유하는 객체들이 각기 다른 방식으로 동작할 수 있게 함
-	런타임 다형성: 런타임 시점에서 메서드 호출을 결정하기 때문에, 객체의 실제 타입에 따라 다른 메서드가 호출될 수 있다. 
-	유지보수 용이: 새로운 클래스나 메서드를 추가할 때 기존 코드를 수정할 필요가 줄어든다. 


Object oriented paradigm compared to procedural programming
-	OOP는 객체 중심 – 데이터+함수 캡슐화 하고 상속, 다형성을 통해 유연성 높임
-	Procedural은 절차 중심 – 명령어의 순서에 따라 실행, 데이터와 함수의 분리

OOP의 encapsulation이란 무엇인가?
-	객체의 상태(data)를 보호하고 외부에서 직접 접근하지 못하도록 하는 것을 의미합니다. 이는 객체의 data를 직접 접근하는 대신, method를 통해서만 접근할 수 있도록 하여 데이터의 무결성을 유지함.

OOP에서 Information hiding은 무엇인가?
-	객체의 내부 구현 세부 사항을 외부에 감추고, 필요한 정보나 기능만을 외부에 제공하는 것을 의미함.

Information hiding과 encapsulation의 차이는 무엇인가
-	관련된 개념이지만, 서로 다른 측면을 강조
-	Encapsulation - 객체의 데이터(필드)와 그 데이터를 조작하는 메서드(함수)를 하나의 단위로 묶는 것을 의미
-	Information hiding -  내부 구현 세부 사항을 외부에 감추고, 객체가 제공하는 공용 인터페이스를 통해서만 상호작용하도록 하는 것을 의미

Overloading vs Overriding?
-	Overloading - 같은 이름의 메서드를 여러 개 정의하는 것을 의미. 이때, 메서드의 매개변수 목록(타입, 개수, 순서)이 달라야 함.
-	Overriding - 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것을 의미. 클래스의 메서드와 동일한 이름, 매개변수 목록, 반환 타입을 가진 메서드를 제공.

OOP에서 substitutability란 무엇인가?
-	객체가 동일한 인터페이스를 구현하거나 동일한 상위 클래스를 상속받는 한, 프로그램의 다른 부분에서 해당 객체를 상호 교환하여 사용할 수 있어야 한다는 원칙
-	SOLID의 Liskov Substitution Principle, LSP 로 설명 됨
	만약 S가 T의 하위 타입이라면, 프로그램의 속성을 변경하지 않고 T 타입의 객체를 S 타입의 객체로 대체할 수 있어야 한다

Generic Class vs Template
-	둘 다 클래스나 메서드 정의 시 타입 파라미터를 사용하여 다양한 타입에 대해 동작할 수 있도록 합니다.
-	제네릭은 타입 소거(type erasure)를 사용하여 런타임에 동작하고, 템플릿은 컴파일 시간에 코드를 생성합니다.


State Machine Diagram에서 Event가 무엇인가? 예를 들어라
-	상태 전이를 일으키는 특정한 발생 상황이나 조건을 의미
-	상태 (States)
	NoQuarter: 동전을 넣지 않은 상태
	HasQuarter: 동전을 넣은 상태
	Sold: 풍선을 판매한 상태
	SoldOut: 재고가 없는 상태
-	이벤트 (Events)
	insertQuarter(): 동전을 넣는 이벤트
	ejectQuarter(): 동전을 빼는 이벤트
	turnCrank(): 손잡이를 돌리는 이벤트
	dispense(): 풍선껌을 내보내는 이벤트

Use Case Relationship
-	Association – Use Case와 Actor 간의 상호 작용을 나타냅니다. 실선으로 표시
-	Include - 한 유스케이스가 다른 유스케이스를 반드시 포함하는 경우
-	Extend - 유스 케이스의 기능을 추가적으로 확장하거나 특화하는 경우
-	Generalization - 터 간 또는 유스케이스 간의 상속 관계를 나타냄

Use Case Granularity of Use Cases
-	Find Grained: 유스케이스가 매우 상세하고 구체적인 동작을 정의. 나의 유스케이스가 작고 구체적인 기능을 수행하거나 단일 작업을 설명합니다.
-	Coarse-Grained: 유스케이스가 상대적으로 광범위하고 포괄적인 동작을 정의. 하나의 유스케이스가 여러 관련 기능이나 작업을 포함

Activity Diagram은 언제 사용되나?
-	시스템의 동작을 시각적으로 표현하는 데 사용되는 다이어그램입니다. 주로 시스템의 워크플로우나 비즈니스 프로세스를 모델링할 때 유용

Use Case Diagram
-	언제 사용되나?  목표 시스템의 기능적 요구사항 파악할 때 쓰임
-	Use Case Description
	유스케이스의 세부적인 기능과 동작을 문서화한 것
-	Use Case Scenario
	유스케이스의 실제 실행 흐름을 설명하는 구체적인 사례
	Basic Flow / Alternative Flow / Exception Flow

Sequence diagram의 workflow related to use case description은?
-	Sequence Diagram은 시스템 내 객체들 간의 상호작용을 시간 순서대로 보여주는 UML 다이어그램입니다. 주로 유스케이스 설명(Use Case Description)에 따라 특정 시나리오를 자세히 묘사하는 데 사용됩니다. 시퀀스 다이어그램은 유스케이스가 수행되는 동안 발생하는 메시지와 메서드 호출을 시각적으로 표현합니다.

Applying MVC style paradigm in drawing Sequence diagram
User                    View                   Controller                   Model
|                         |                         |                           |
|  -----상품목록요청---->  |                         |                           |
|                         |  ----getProductList()---> |                            |
|                         |                         | -----fetchProducts()---->    |
|                         |                         | <-----삼품데이터반환-----   |
|                         |<-- updateProductList---  |                           |
|                         |      (products)         |                           |
|  <--- 상품목록 표시---   |                         |                           |
|                         |                         |                           |
|                         |                         |                           |

State Machine Diagram
-	Transition: 상태(State)에서 다른 상태로의 변화
-	Event: 상태 전이를 유발하는 사건
-	Guard: 전이가 발생하기 위한 조건
-	Action: 전이 과정에서 수행되는 작업
 
Timing Diagram
-	객체나 구성 요소의 상태 변화와 메시지 전송을 시간 축에 따라 시각적으로 표현하는 도구입니다. 타이밍 다이어그램은 시스템의 시간적 동작을 명확히 이해하고, 특정 이벤트나 조건이 발생하는 시점과 순서를 파악하는 데 유용합니다.

Component Diagram
-	Provided Interface와 Required Interface를 명확히 표현함으로써, 시스템의 모듈 간 상호작용을 시각적으로 이해하고, 시스템의 유연성, 확장성, 유지보수성을 향상시킬 수 있습니다.
-	Provided interface: 특정 컴포넌트가 외부에 제공하는 기능을 정의한 인터페이스
-	Required interface: 특정 컴포넌트가 동작하기 위해 외부로부터 필요로 하는 기능을 정의한 인터페이스. 
-	Pluggable Object: 시스템의 특정 부분이 쉽게 교체되거나 확장될 수 있도록 설계된 객체나 컴포넌트

Deployment Diagram
-	 Node: 시스템의 물리적 요소를 나타내며, 컴퓨터, 서버, 네트워크 장비와 같은 하드웨어 장치
-	Artifacts: Artifact는 Node에 배포되며, 소프트웨어의 구체적인 실행 단위를 의미. 시스템의 물리적 구현을 나타내는 요소로, 소프트웨어 파일, 라이브러리, 데이터베이스 스키마 등입니다. 

UML Constructs for Parallel Processing available in UML Diagrams
-	Activity Diagram – Fork and Join
-	State Machine Diagram – Concurrent State
-	Sequence Diagram – par combined fragment 여러 개의 메시지가 동시에 실행되는 상황을 표현

Diagram Consistency
-	Activity Diagram vs Use Case Diagram
	Activity Diagram의 흐름이 Use Case Diagram의 유스 케이스의 시나리오와 일치하는지 확인. 
	Use Case Diagram에서 정의된 모든 유스 케이스가 Activity Diagram에 반영되어 있는지 확인
-	State Machine Diagram vs Class Diagram
	State Machine Diagram의 상태와 전이와 Class Diagram의 클래스가 일치하는지 검토
	상태와 속성 연관, 상태와 메서드 연관, 상태 전이의 원인과 결과 확인
-	Use Case Model(UCM), Class Diagram(CD) and Sequence Diagram(SD)
	UCM and CD
	유스 케이스가 클래스를 어떻게 활용하는지 검토하고, 클래스가 유스 케이스의 요구를 충족하는지 확인합니다
	CD and SD
	시퀀스 다이어그램의 메서드 호출과 상호작용이 클래스 다이어그램에 정의된 내용과 일치하는지 확인합니다
	SD and UCM
	유스 케이스가 시퀀스 다이어그램에서 적절히 표현되었는지 검토하고, 시나리오와 상호작용이 일치하는지 확인합니다.

SOLID
-	Single Responsibility Principle, SRP
	클래스는 오직 하나의 책임만 가져야 하며, 하나의 변경 이유만 가져야 한다.
-	Open/Closed Principle, OCP
	확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다
-	Liskov Substitution Principle, LSP
	객체는 부모 타입의 객체로 대체 가능해야 하며, 대체된 객체가 부모 클래스의 행동을 올바르게 수행해야 한다.
-	Interface Segregation Principle, ISP
	클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다
-	Dependency Inversion Principle, DIP
	고수준 모듈은 저수준 모듈에 의존하지 말고, 추상화에 의존해야 한다. 추상화는 세부 사항에 의존하지 말고, 세부 사항이 추상화에 의존해야 한다

What are the benefits of applying SOLID?
-	유지보수성 향상: 코드 변경이 용이하고 관리가 쉬워집니다.
-	확장성 증가: 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있습니다.
-	재사용성 향상: 독립적이고 재사용 가능한 모듈을 제공합니다.
-	테스트 용이성: 독립적으로 테스트할 수 있는 구조를 제공합니다.
-	코드 품질 향상: 명확하고 구조적인 코드를 유지합니다.
-	디버깅과 수정의 용이성: 문제를 신속히 찾고 수정할 수 있습니다.

Give examples of applying separation of Concerns
-	소프트웨어 설계에서 서로 다른 책임을 분리하여 모듈화하고, 각 모듈이 특정 기능에만 집중하도록 하는 원칙입니다. 이는 시스템의 복잡성을 줄이고, 유지보수와 확장성을 개선하는 데 도움을 줍니다.
-	Layered Architecture: 시스템을 여러 계층으로 나누어 각 계층이 특정 책임만을 맡도록 한다
-	SOA: 기능을 서비스 단위로 분리하여 독립적으로 동작하도록 한다. 
-	MVC Pattern: 모델, 뷰, 컨트롤러를 분리하여 각기 다른 책임을 맡도록 한다. 
-	Modularization: 소프트웨어를 모듈 단위로 나누어 각 모듈이 특정 기능을 수행하도록 한다.

What are tie differences between Cohesion and Coupling?
-	Cohision: 모듈이나 클래스가 자신의 책임에 얼마나 잘 집중하고 있는지를 평가
-	Coupling: 모듈이나 클래스 간의 의존성 정도를 평가

What is the Information Hiding mechanism in OOP?
-	OOP에서 클래스의 내부 구현 세부사항을 외부에서 접근할 수 없도록 숨기고, 필요한 정보와 기능만을 공개하는 개념

Abstraction
-	복잡한 시스템의 세부 사항을 숨기고 본질적인 정보와 기능만을 제공하는 원칙입니다. 이를 통해 시스템의 복잡성을 줄이고, 이해와 유지보수를 용이하게 하며, 모듈화와 재사용성을 높일 수 있습니다.

Refinement
-	소프트웨어 설계에서 초기 추상적인 개념을 점진적으로 구체화하여, 구현 가능한 형태로 발전시키는 과정

What are the benefits of OCP?
-	유지보수성과 확장성이 향상되고, 결합도가 감소하며, 테스트 용이성과 코드 재사용성이 증가합니다. 또한 디자인의 유연성과 리팩토링 용이성을 제공하여 소프트웨어의 품질과 안정성을 높이는 데 도움을 줍니다.

What are the mechanisms for implementing OCP?
-	추상화, 인터페이스와 구현 분리, 디자인 패턴, 의존성 주입, 구성 요소의 분리
-	Abstraction: 추상화를 통해 구체적인 구현을 숨기고, 모듈의 기능을 추상적인 인터페이스나 클래스를 통해 정의
-	인터페이스와 구현 분리 (Interface Segregation): 인터페이스를 변경하지 않고 새로운 기능을 추가 가능.
-	Design Patterns: 다양한 디자인 패턴은 OCP를 구현하는 데 도움이 됨. Strategy Pattern, Decorator Pattern, Template Method Pattern 등이 있음.
-	의존성 주입 (Dependency Injection) 
-	구성 요소의 분리 (Component Separation)
-	

Principles of Design Patterns
-	Interface Separated from Implementation 
-	Substitution with various Implementation. 
-	OCP

Classification of Design Patterns
-	Creation Patterns:
	Singleton Pattern, Factory Method Pattern, Abstract Factory Pattern, Builder Pattern, Prototype Pattern
-	Structural Patterns:
	Adapter Pattern, Decorator Pattern, Proxy Pattern, Bridge Pattern, Composite Pattern, Flyweight Pattern, Composite Pattern
-	Behavioral Pattern:
	Observer Pattern, Command Pattern, Strategy Pattern, Template Method Pattern, State Pattern, Chain of Responsibility Pattern, Memento Pattern, Interpreter Pattern

For each Pattern
-	Situation
-	Structure in Class Diagram
-	Collaboration
-	Pros and Cons

Explain how OO mechanism are utilized in X pattern?

Common OO Mechanism found in Design Patterns
-	Abstraction with Interface
-	Inheritance / Specialization
-	Dynamic Binding
-	Delegation

What are the similarity & differences between <X pattern> and <Y pattern>

Advanced Topics
-	Similarity between Patterns
-	Difference between Patterns

Why is Process Quality important?
-	프로세스 품질이 높으면 일관성과 예측 가능성, 효율성, 품질 개선, 위험 관리, 고객 만족도 증가, 지속적인 개선 촉진, 규모 확장 지원, 자원 관리 최적화 등의 장점을 제공

Why is Quality-in-Use important?
-	사용 품질 (Quality-in-Use)은 사용자의 실제 경험 반영, 효율성 개선, 문제 해결의 우선 순위 설정, 고객 만족도 향상, 경쟁력 강화, 비용 절감, 반복적 개선 가능, 실제 환경에서의 성능 검증 등 다양한 장점을 제공

Definition of SW Quality
-	소프트웨어 품질은 소프트웨어가 요구 사항을 충족하고, 성능, 신뢰성, 유지 보수성, 사용성, 보안 등 다양한 품질 특성을 만족하는 정도를 의미

Types of Quality Aspects
-	Process Quality(프로세스품질): 소프트웨어 개발과 유지보수 과정에서 적용되는 프로세스와 방법론의 품질
-	Internal Quality(내부품질): 소프트웨어 내부 구조와 코드의 품질
-	External Quality (외부품질): 사용자가 소프트웨어와 상호작용할 때 경험하는 품질
-	Quality in Use (사용품질): 소프트웨어가 실제 사용 환경에서 어떻게 작동하는지를 평가하는 품질



