Software Architect?
A Software development expert who makes high-level design choices and dictates technical standards, including software coding standards, tools and platforms.
High level 설계를 선택하고 소프트웨어 코딩 표준, 도구 및 플랫폼을 포함한 기술 표준을 지시하는 소프트웨어 개발 전문가입니다.

Software Architecture?
Software architecture refers to the high-level structures of a software system and the discipline of creating such structures
소프트웨어 아키텍처는 소프트웨어 시스템의 상위 수준 구조와 그러한 구조를 만드는 분야를 나타냅니다.
-	Schematic Architecture
	A structured and visual representation of the structural elements of a target system, their roles, and relationships among the elements. A stable foundation for making further architectural decisions.
	대상 시스템의 구조적 요소, 해당 역할, 요소 간 관계를 체계적이고 시각적으로 표현한 것입니다. 추가 아키텍처 결정을 위한 안정적인 기반
-	Design for Architecture View
	1) Functional view, - 함수 data처리 
	2) Information view, - data관점의 설계
	3) Behavior view, - 실행순서 관련, 기능이 아니다. 
	4) Deployment view, -
-	Design for NFR

SD) Class Diagram있는데 구조를 나타내는 Compound Diagram있나?
-	Class Diagram + Sequence Diagram: 클래스 구조와 객체 간의 상호작용을 동시에 보여줌으로써 정적 구조와 동적 행동을 결합하여 이해를 돕습니다.
-	Component Diagram + Deployment Diagram: 소프트웨어 구성 요소와 물리적 배포 구성을 함께 보여줌으로써 소프트웨어의 논리적 구조와 물리적 배포를 연계시켜 설명합니다.
-	Package Diagram + Class Diagram: 패키지 간의 관계를 고수준에서 보여주면서 각 패키지 내부의 클래스 구조를 세부적으로 나타냅니다.
SEI 4+1 View
-	Logical / Structural View, - Functionality
-	Process / Behavior View,  - performance
-	Development(Developer) / Implementation View, - software management
-	Physical / Deployment View. – system topology
-	+1 Scenario / Use Case View

ISO 9126, Conventional NFRs
-	Functionality
-	Reliability
-	Usability
-	Efficiency
-	Maintainability
-	Portability

DFD Diagram
-	Process (O)
-	Terminal (ㅁ)
-	Data Store (=)
-	Data Flow ()

DFD for boundary Context
-	System Functionality ↔ Process of DFD
-	Elements in Boundary ↔ Terminal of DFD
-	Persistent Data ↔ Data Store of DFD
-	Informational Flow ↔ Data Flow of DFD

UCD include, extend?
-	Include: 한 use case가 다른 use case를 포함하는 관계를 나타냅니다. 이는 한 use case가 수행되는 과정에서 다른 use case가 필수적으로 포함되어야 하는 경우에 사용됩니다.
-	Extend: 한 use case가 다른 use case를 확장하는 관계를 나타냅니다. 이는 한 use case가 수행되는 과정에서 다른 use case의 기능을 추가로 사용하는 경우에 사용됩니다.

Design 단계에서의 High Level Class Diagram  Persistent data
 Functional Component 

Key Elements of CD
-	Class
-	Relationaships
	Dependency   ---------▷ 
	Association    ────>
	Aggregation ◇────>
	Composition ◆────>
	Inheritance    ────▷

HAL의 주된 사용 용도는? 어떨 때 쓰면 좋은가?
-	HW Specific을 user에게 숨기고 interface를 제공 (SD)
-	HW와 SW분리하여 HW 호완성 보장하고 SW 개발 및 유지보수 용이성 제공

Mediator pattern vs Facace pattern차이?
Mediator 패턴은 객체 간의 상호작용을 중앙 집중화하여 관리하고, Facade 패턴은 복잡한 서브시스템의 인터페이스를 단순화하여 사용자가 쉽게 접근할 수 있도록 합니다.

Required Interface 용도
-	SW 시스템 유지 보수 / 확장 쉽게 한다
-	가변적 기능은 required interface 밖에서 구현 ex) template method pattern

Class method (static), Class attribute (static) 용도?
-	Instance간의 통계 counting, class수준 관리

Software Defined X (SDx) :  x --> everything
다양한 기술 영역에서 소프트웨어 정의 접근 방식을 채택한 것을 의미합니다. SDx는 하드웨어 중심의 전통적인 시스템에서 벗어나 소프트웨어 중심의 유연하고 효율적인 시스템을 만드는 데 중점을 둡니다

Digital twin?
디지털 트윈(Digital Twin)은 물리적 객체, 시스템, 프로세스 또는 공간의 디지털 복제본을 의미합니다. 이는 실제 세계의 자산이나 환경을 가상 세계에 재현하여 실시간 데이터를 통해 상태를 모니터링하고, 시뮬레이션 및 분석을 수행하며, 예측 및 최적화를 가능하게 합니다. 디지털 트윈은 IoT(사물 인터넷), 빅 데이터, AI(인공지능) 등 다양한 기술을 활용하여 구현됩니다.

Action과 Activity의 차이가 무엇인가?
-	action과 activity는 둘 다 행동을 나타내지만, 그 추상화 수준과 역할에 차이가 있습니다
-	Action : 가장 작은 행동 단위입니다. 일반적으로 한 단계의 작업을 나타내며, 더 이상 쪼갤 수 없는 원자적 행동을 의미합니다
-	Activity: 여러 action을 포함하는 더 큰 단위의 행동을 나타냅니다. 여러 action들이 모여 특정 목표를 달성하기 위한 흐름을 나타냅니다

Try-catch vs switch-case 차이?
-	공통점: Fault나면 실행
-	차이점: SoC ( Separation of Concern )  try: main logic 만 생각하고 
                                    catch: 별도로 생각하자는 idea
-	생각의 관점이 다른 try-catch로 분리하여 각 모듈이 특정 기능적 관심사만을 처리하도록 분리함으로써, 시스템의 복잡성을 줄이고, 코드의 재사용성, 유지보수성, 확장성을 향상시키는 데 도움을 줍니다

State Machine Diagram은 어떤 정보를 주는가?
-	Target component안에 state가 몇개 인지 보인다
-	State 허용 가능한 state transition보인다. 
-	State Machine Diagram은 시스템의 동작을 상태와 전이로 시각화하여, 시스템이 특정 이벤트나 조건에 따라 어떻게 반응하는지 명확히 보여줍니다. 이를 통해 객체의 라이프사이클, 복잡한 제어 흐름, 시스템 동작 분석, 디버깅, 테스트, 문서화 등에 큰 도움을 줍니다.

Consistency between Functional & Behavior
-	Mapping activity/action for a given use case
-	Mapping use cases for a given action/activity

Observer pattern은 어떤 situation에서 사용하는가?
-	Observer 패턴은 객체의 상태 변화가 있을 때, 그 변화를 감지하고 이에 대응하여 다른 객체들에 알림을 주어야 할 때 유용하게 사용됩니다. 이는 주로 객체들 간의 1대다(one-to-many) 의존성을 정의하는 상황에서 사용됩니다.
-	상태 변경 알림: 객체의 상태가 변경될 때, 그 변화를 여러 객체들에게 통지해야 하는 경우에 사용됩니다.
-	실시간 데이터 피드: 실시간으로 업데이트되는 데이터를 여러 객체들이 구독(subscribe)하고, 데이터가 업데이트될 때마다 이를 수신해야 하는 경우에 사용됩니다. 예를 들어, 주식 시장 데이터 피드, 스포츠 경기 결과 업데이트 등이 있습니다
-	모델-뷰 관계: 모델(Model)과 뷰(View) 간의 관계에서 모델의 상태가 변경될 때 뷰가 이를 반영해야 하는 경우에 사용됩니다. 이는 주로 MVC (Model-View-Controller) 아키텍처에서 모델과 뷰 간의 동기화를 위해 사용됩니다

---------------------------------------------------------------------------

What is the typical drawback of procedural programs such as C?
-	함수단위로 코드 재사용이 가능하지만, OOP 언어에비해 재사용성이 떨어짐. 
새로운 기능을 추가하거나 수정할 때 기존코드 재사용하는데 한계 있음.
-	유지보수 어려워: 프로그램 복잡해질수록 유지보수 어렵, 코드가 길어질수록 의존성 높아짐. 
-	데이터 보안 및 은닉의 부족 : 함수가 데이터를 접근 및 수정이 자유로움, 데이터 
은닉 어려워
-	다형성 & 상속의 부재: 코드의 유연성 과 확정성 제한


Object oriented paradigm compared to procedural programming
-	OOP는 객체 중심 – 데이터+함수 캡슐화 하고 상속, 다형성을 통해 유연성 높임
-	Procedural은 절차 중심 – 명령어의 순서에 따라 실행, 데이터와 함수의 분리
























